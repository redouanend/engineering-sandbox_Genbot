# Libraries
import socket
import threading
import traceback
import time
import webview
from pathlib import Path
from http.server import HTTPServer, SimpleHTTPRequestHandler

# Our code
import go_to_moodle


"""
All the code concerning setuping and running the HTML server has been generated 
by AI. It is working as expected for instance.
The prompt to generate the code was: 
Run a simple HTTP server in a new thread to serve the files in the gui directory.
"""
GUI_DIR = Path(__file__).resolve().parent / "gui"
PORT = 8765
def run_server():
    handler = lambda *args, **kwargs: SimpleHTTPRequestHandler(
        *args, directory=str(GUI_DIR), **kwargs
    )
    try:
        server = HTTPServer(("", PORT), handler)
        server.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.serve_forever()
    except OSError as e:
        print(f"Erreur serveur (port {PORT} ?): {e}", flush=True)



"""
Expose Python functions to the HTML interface through pywebview.
Methods defined here can be called from JavaScript using :
    window.pywebview.api.<method>()
This is the bridge between the GUI and backend logic."""
# Runs backend tasks in a background thread to avoid freezing the UI.
# Stores progress logs so the frontend can poll and display them.
class Api:
    def __init__(self):
        self._logs: list[str] = []
        self._is_running: bool = False
        self.login_event = threading.Event()
        self._assignments: list[dict] = []
        self._login_required: bool = False


    def ping(self):
        #simple connectivity test between the GUI (JS) and Python backend.
        return "python connect√© üëç"
    
    def start_sync(self) -> dict:
        # Starts the Moodle sync in a separate thread (non-blocking for the GUI).
        if self._is_running:
            return {"ok": False, "error": "Sync already running"}
        
        self._logs.clear()
        self._is_running = True
        self._logs.append("Starting sync‚Ä¶")
        self._login_required = False

        t = threading.Thread(target=self._sync_worker, daemon=True)
        t.start()
        return {"ok": True}
    
    def get_status(self) -> dict:
        # Returns current state + accumulated logs for the frontend (polling).
        return {
            "running": self._is_running,
            "logs": self._logs,
            "assignments": self._assignments,
            "login_required": self._login_required,
        }
    
    def _sync_worker(self) -> None:
        # Background worker that runs the existing backend workflow.
        try:
            self._logs.append("Running backend workflow‚Ä¶")
            # # Store returned assignments so the frontend can render them.
            self._assignments = go_to_moodle.main() or []
            self._logs.append(f"Sync completed ‚úÖ ({len(self._assignments)} assignments)")
        except Exception:
            self._logs.append("Sync failed ‚ùå")
            self._logs.append(traceback.format_exc())
        finally:
            self._is_running = False

    def confirm_login(self):    # Called from the GUI when the user confirms login (e.g., after 2FA). This unblocks the backend workflow waiting for authentication.
        #User confirmed login (e.g. 2FA finished),
        self._login_required = False
        self.login_event.set()
        return "Login confirmed"
    

def main():

    """
    As the setuping and running HTML server, the 3 lines bellow are also
    generated by AI. (same function)
    """
    server_thread = threading.Thread(target=run_server, daemon=True)
    server_thread.start()
    time.sleep(0.5)
    print("2. Serveur pr√™t, cr√©ation fen√™tre...", flush=True)

    # Global API instance used by backend modules (e.g., login.py)
    api_instance = Api()

    webview.create_window(
        "Never be late",
        url=f"http://127.0.0.1:{PORT}/index.html",
        js_api=api_instance,                            # Expose Python API to the HTML/JS interface
        width=800,
        height=500,
        resizable=True,
    )
    webview.start(debug=False)


#For debugging, will be removed when main() will be call in another script.
if __name__ == "__main__":
    main()